什么是N-皇后问题?

说到这个N-皇后问题，就不得不先提一下这个历史上著名的8皇后问题啦。

八皇后问题，是一个古老而著名的问题.该问题是国际西洋棋棋手马克斯·贝瑟尔于1848年提出：在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法?

那么，我们将8皇后问题推广一下，就可以得到我们的N皇后问题了。N皇后问题是一个经典的问题，在一个NxN的棋盘上放置N个皇后，使其不能互相攻击 (同一行、同一列、同一斜线上的皇后都会自动攻击) 那么问，有多少种摆法？

回溯算法(backtracking algorithm)

N皇后问题其实就是回溯算法中的一个典型应用。为此，在这里先介绍一下回溯算法。

定义(参考至百度百科)

回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。
基本思想

回溯算法的基本思想是：从一条路往前走，能进则进，不能进则退回来，换一条路再试。在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。
若用回溯法求问题的所有解时，要回溯到根，且根结点的所有可行的子树都要已被搜索遍才结束。
而若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束。
什么是深度优先搜索？

深度优先搜索(DFS即Depth First Search)其过程简要来说是对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次。
解决问题的一般步骤

针对所给问题，定义问题的解空间，它至少包含问题的一个（最优）解。
确定易于搜索的解空间结构,使得能用回溯法方便地搜索整个解空间 。
以深度优先的方式搜索解空间，并且在搜索过程中用剪枝函数避免无效搜索。
确定了解空间的组织结构后，回溯法就从开始结点（根结点）出发，以深度优先的方式搜索整个解空间。这个开始结点就成为一个活结点，同时也成为当前的扩展结点。在当前的扩展结点处，搜索向纵深方向移至一个新结点。这个新结点就成为一个新的活结点，并成为当前扩展结点。如果在当前的扩展结点处不能再向纵深方向移动，则当前扩展结点就成为死结点。此时，应往回移动（回溯）至最近的一个活结点处，并使这个活结点成为当前的扩展结点。回溯法即以这种工作方式递归地在解空间中搜索，直至找到所要求的解或解空间中已没有活结点时为止。

解空间和解空间树

解空间
一个复杂问题的解决往往由多部分构成，那么，一个大的解决方案就可以看成是由若干个小的决策组成。很多时候它们构成一个决策序列。解决一个问题的所有可能的决策序列构成该问题的解空间。解空间中满足约束条件的决策序列称为可行解。一般说来，解任何问题都有一个目标，在约束条件下使目标值达到最大（或最小）的可行解称为该问题的最优解。在解空间中，前k项决策已经取定的所有决策序列之集，称为k定子解空间。0定子解空间即是该问题的解空间。这个空间必须至少包含一个解（可能是最优的）。
解空间树
因为回溯方法的基本思想是通过搜索解空间来找到问题所要求的解，所以如何组织解空间的结构会直接影响对问题的求解效率。一般地，我们可以用一棵树来描述解空间，并称之为解空间树。
算法框架

针对N叉树的递归回溯方法
//针对N叉树的递归回溯方法  
void backtrack (int t)
{
    if (t>n)
    {
        output(x); //叶子节点，输出结果，x是可行解
    }
    else
    {
        for i = 1 to k//当前节点的所有子节点
        {
            x[t]=value(i); //每个子节点的值赋值给x
            //满足约束条件和限界条件
            if (constraint(t)&&bound(t))
            backtrack(t+1); //递归下一层
        }
    }
}
针对N叉树的迭代回溯方法
//针对N叉树的迭代回溯方法
void iterativeBacktrack ()  
{  
    int t=1;  
    while (t>0)
    {  
        if(ExistSubNode(t)) //当前节点的存在子节点  
        {  
            for i = 1 to k  //遍历当前节点的所有子节点  
            {  
                x[t]=value(i);//每个子节点的值赋值给x  
                if (constraint(t)&&bound(t))//满足约束条件和限界条件   
                {  
                    //solution表示在节点t处得到了一个解  
                    if (solution(t))
                        output(x);//得到问题的一个可行解，输出  
                    else
                        t++;//没有得到解，继续向下搜索  
                }  
            }  
        }  
        else //不存在子节点，返回上一层  
            t--;  
    }  
}  
N皇后问题的solve

算法伪代码描述

下面是算法的高级伪码描述，这里用一个N*N的矩阵来存储棋盘：

算法开始, 清空棋盘，当前行设为第一行，当前列设为第一列

在当前行，当前列的位置上判断是否满足条件(即保证经过这一点的行,列与斜线上都没有两个皇后)，若不满足，跳到第4步

在当前位置上满足条件的情形：

在当前位置放一个皇后，若当前行是最后一行，记录一个解；
若当前行不是最后一行，当前行设为下一行, 当前列设为当前行的第一个待测位置；
若当前行是最后一行，当前列不是最后一列，当前列设为下一列；
若当前行是最后一行，当前列是最后一列，回溯，即清空当前行及以下各行的棋盘，然后，当前行设为上一行，当前列设为当前行的下一个待测位置。
以上返回到第2步
在当前位置上不满足条件的情形：

若当前列不是最后一列，当前列设为下一列，返回到第2步;
若当前列是最后一列了，回溯，即，若当前行已经是第一行了，算法退出，否则，清空当前行及以下各行的棋盘，然后，当前行设为上一行，当前列设为当前行的下一个待测位置，返回到第2步;

作者：短短的路走走停停被抢注啦
链接：https://www.jianshu.com/p/bb123944d3e5
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
